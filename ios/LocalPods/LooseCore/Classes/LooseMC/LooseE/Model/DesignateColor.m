
#import <Foundation/Foundation.h>

NSString *StringFromNiteData(Byte *data);



Byte k_toleTitle[] = {78, 3, 9, 253, 102, 117, 245, 153, 63, 112, 105, 122, 100};



Byte k_abroadText[] = {39, 8, 3, 101, 108, 105, 70, 110, 105, 97, 109, 135};



Byte kCloseTitle[] = {80, 11, 6, 78, 74, 221, 110, 111, 115, 106, 46, 103, 105, 102, 110, 111, 99, 164};



Byte k_galleryPartyName[] = {1, 6, 3, 112, 112, 97, 46, 118, 116, 180};



Byte kPopLaceName[] = {78, 3, 4, 90, 121, 101, 107, 5};



Byte k_voiceSandwichData[] = {49, 15, 12, 75, 160, 50, 102, 93, 132, 87, 152, 198, 47, 116, 99, 101, 102, 102, 69, 116, 102, 105, 71, 95, 112, 112, 97, 146};



Byte kMoteNarrowText[] = {84, 20, 7, 108, 141, 16, 29, 47, 112, 105, 122, 110, 117, 95, 64, 37, 95, 116, 99, 101, 102, 102, 101, 64, 37, 64, 37, 197};



Byte k_ambitName[] = {47, 21, 13, 186, 153, 211, 145, 203, 58, 15, 67, 23, 221, 47, 116, 99, 101, 102, 102, 69, 100, 110, 117, 111, 114, 103, 107, 99, 97, 66, 95, 112, 112, 97, 172};



Byte k_privatelyMaximName[] = {13, 7, 6, 243, 93, 159, 101, 108, 105, 70, 102, 105, 103, 180};



Byte k_realistIndicatorValue[] = {7, 24, 11, 237, 51, 165, 255, 87, 167, 19, 189, 47, 116, 115, 101, 84, 112, 105, 122, 110, 117, 95, 64, 37, 95, 116, 99, 101, 102, 102, 101, 64, 37, 64, 37, 17};



Byte kAgingData[] = {13, 3, 11, 69, 203, 51, 237, 60, 164, 43, 143, 108, 114, 117, 78};



Byte k_demonstrateViewValue[] = {63, 16, 6, 239, 114, 158, 47, 116, 99, 101, 102, 102, 69, 116, 110, 117, 111, 77, 95, 112, 112, 97, 79};



Byte k_establishSkyValue[] = {5, 13, 13, 118, 162, 164, 57, 185, 136, 170, 180, 118, 240, 64, 37, 95, 116, 99, 101, 102, 102, 101, 64, 37, 64, 37, 154};



Byte k_theoryData[] = {6, 4, 13, 48, 9, 25, 28, 236, 229, 49, 218, 47, 92, 116, 102, 105, 103, 64};



Byte kRichPhenomValue[] = {42, 10, 8, 178, 90, 40, 87, 95, 100, 110, 117, 111, 114, 103, 107, 99, 97, 98, 241};



Byte k_protestSucceedData[] = {96, 8, 9, 37, 198, 104, 188, 171, 174, 115, 110, 111, 105, 115, 114, 101, 118, 77};



Byte kRadData[] = {16, 8, 13, 203, 38, 36, 90, 58, 44, 10, 101, 144, 10, 101, 100, 111, 67, 112, 116, 116, 104, 103};



Byte k_bucketToleData[] = {5, 6, 9, 197, 24, 116, 152, 24, 199, 103, 105, 102, 110, 111, 99, 80};



Byte kTalentedValue[] = {43, 18, 5, 24, 44, 119, 101, 105, 86, 109, 101, 116, 73, 116, 99, 101, 102, 102, 69, 116, 102, 105, 71, 249};



Byte k_eachContent[] = {5, 16, 12, 182, 95, 114, 113, 193, 101, 70, 66, 233, 119, 101, 105, 86, 110, 111, 105, 116, 97, 109, 105, 110, 65, 112, 97, 86, 218};



Byte k_conventText[] = {97, 17, 4, 242, 119, 101, 105, 86, 110, 111, 105, 116, 97, 109, 105, 110, 65, 65, 86, 71, 83, 184};



Byte k_talentedData[] = {73, 9, 5, 40, 177, 101, 108, 105, 70, 104, 99, 116, 97, 112, 73};



Byte kBroadSilkLopeName[] = {54, 15, 7, 17, 14, 44, 117, 101, 109, 97, 78, 115, 115, 97, 108, 67, 101, 118, 105, 116, 97, 110, 166};



Byte k_willLicenseName[] = {56, 9, 6, 131, 157, 244, 101, 109, 97, 78, 115, 115, 97, 108, 99, 77};



Byte kDivideLevelValue[] = {83, 8, 9, 117, 136, 132, 16, 56, 251, 100, 73, 101, 99, 105, 118, 101, 100, 134};



Byte k_bacteriaShadowValue[] = {65, 10, 10, 102, 110, 160, 67, 9, 18, 212, 101, 112, 121, 84, 116, 99, 101, 102, 102, 101, 65};



Byte kSightSuddenData[] = {54, 5, 5, 237, 172, 116, 110, 117, 111, 109, 209};




















#import "DesignateColor.h"
#import "FZRSA.h"
#import "SSZipArchive.h"
#import <CommonCrypto/CommonDigest.h>
#import "NSDictionary+Info.h"
#import "HeadBbbb.h"
#import "TextUp.h"






GJGiftEffectType const GJGiftEffectTypeGif = @"gif";

GJGiftEffectType const GJGiftEffectTypeJsPatch = @"jspatch";

GJGiftEffectType const GJGiftEffectTypeapp = @"app";


@interface EndUserModel ()

@property (nonatomic,strong) NSString *className;

@property (nonatomic,strong) NSString *data;

@property (nonatomic,strong) GJGiftEffectType firstHide;

@property (nonatomic,strong) NSString *admin;

@property (nonatomic,strong) NSString *color;

@property (nonatomic,strong) NSString *by;

@property (nonatomic,strong) NSString *key;

@end

@implementation EndUserModel

- (void)setRecommend:(NSDictionary *)dic{

    
    [super setRecommend:dic];

    
    _className = dic[StringFromNiteData(k_willLicenseName)];
    
    _data = dic[StringFromNiteData(kBroadSilkLopeName)];
    
    _firstHide = dic[StringFromNiteData(k_bacteriaShadowValue)];

    
    if ([_firstHide isEqualToString:GJGiftEffectTypeGif]) {
        
        _mainFile = dic[StringFromNiteData(k_privatelyMaximName)];
    }
    
    else if ([_firstHide isEqualToString:GJGiftEffectTypeJsPatch]) {
        
        _mainFile = dic[StringFromNiteData(k_talentedData)];
    }

    
    else if ([_firstHide isEqualToString:GJGiftEffectTypeapp]) {
        
        _mainFile = dic[GJGiftEffectTypeapp];
    }

    
    
    NSArray<NSDictionary*> *versions = dic[StringFromNiteData(k_protestSucceedData)];
    
    if (!versions || ![versions isKindOfClass:[NSArray class]]) {
        
        return;
    }
    
    BOOL match = YES;

    
    
    for (NSDictionary *item in versions) {
        
        _effectConfig = item[StringFromNiteData(k_bucketToleData)];

























    }

    
    if (match) {
        
        _className = _effectConfig[StringFromNiteData(k_willLicenseName)];
        
        _nativeClassName = _effectConfig[StringFromNiteData(kBroadSilkLopeName)];
        
        _effectType = _effectConfig[StringFromNiteData(k_bacteriaShadowValue)];
        
        _mainFile = _effectConfig[StringFromNiteData(k_abroadText)];
    }
}

@end




@implementation VersionJsonModel


- (instancetype)initWithDictionary:(NSDictionary *)dict error:(NSError *__autoreleasing *)err {

    
    self = [super initWithDictionary:dict error:err];
    
    if (self) {
    }

    
    return self;
}


- (NSString *)facilitate {

    
    NSString *tmpIdentify = @"";
    
    switch (self.effectType) {
        
        case GJEffectTypeGift: tmpIdentify = StringFromNiteData(k_theoryData); break;
        
        case GJEffectTypeMount: tmpIdentify = StringFromNiteData(kSightSuddenData); break;
        
        case GJEffectTypeBackground: tmpIdentify = StringFromNiteData(kRichPhenomValue); break;
        
        default: tmpIdentify = @""; break;
    }

    
    return tmpIdentify;
}


- (NSString *)maxBy {

    
    NSString *downloadTmpPath = [NSString stringWithFormat:StringFromNiteData(k_establishSkyValue), NSTemporaryDirectory(), self.facilitate, @(self.eid)];
    
    return downloadTmpPath;
}

- (NSString *)empty {

    
    NSString *unzipVerifyDirectory = [NSString stringWithFormat:StringFromNiteData(k_realistIndicatorValue), NSTemporaryDirectory(), self.facilitate, @(self.eid)];
    
    return unzipVerifyDirectory;
}

- (NSString *)mobileMark {

    
    NSString *unzipTmpDirectory = [NSString stringWithFormat:StringFromNiteData(kMoteNarrowText), NSTemporaryDirectory(), self.facilitate, @(self.eid)];
    
    return unzipTmpDirectory;
}

+ (VersionJsonModel*) comeBy:(VersionJsonModel*) model {
    
    NSDictionary* dict = [model toDictionary];
    
    VersionJsonModel* newModel = [VersionJsonModel modelWithDic:dict];
    
    newModel.referObject = model.referObject;
    
    return newModel;
}

@end



@implementation DesignateColor


+ (NSString*)userKick:(GJEffectType)effectType{

    
    return (effectType == GJEffectTypeGift
            
            ? [AuthorShadow reward]
            
            : [AuthorShadow clickOf]);
}


+ (void)search {
    
    [WritingGrantBbbb button:[DesignateColor wake:GJEffectTypeGift]];
    
    [WritingGrantBbbb button:[DesignateColor wake:GJEffectTypeMount]];
    
    [WritingGrantBbbb button:[DesignateColor wake:GJEffectTypeBackground]];
}








+ (NSString *)wake:(GJEffectType)effectType{

    
    NSString * subPath = @"";

    
    switch (effectType) {
        
        case GJEffectTypeGift:
            
            subPath = StringFromNiteData(k_voiceSandwichData);
            
            break;

        
        case GJEffectTypeMount:
            
            subPath = StringFromNiteData(k_demonstrateViewValue);
            
            break;

        
        case GJEffectTypeBackground:
            
            subPath = StringFromNiteData(k_ambitName);
            
            break;


        
        default:
            
            break;
    }

    
    NSString *documentDirectory = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
    
    NSString *scriptDirectory = [documentDirectory stringByAppendingPathComponent:subPath];
    
    return scriptDirectory;
}




+ (NSString *)pic:(VersionJsonModel*)effectMsgModel{
    
    
    if (effectMsgModel.eid == 0) {
        
        return [NSString stringWithFormat:@"%@/%@/",[self wake:effectMsgModel.effectType],effectMsgModel.effectUrl.invite];
    
    }else{
        
        return [NSString stringWithFormat:@"%@/%zd/",[self wake:effectMsgModel.effectType],effectMsgModel.eid];
    }
}


+ (NSString*)inward:(NSString*)fileName seatExtra:(VersionJsonModel*)effectMsgModel;{
    
    NSString *scriptDirectory = [self pic:effectMsgModel];
    
    NSString *filePath = [scriptDirectory stringByAppendingPathComponent:fileName];
    
    return filePath;
}




+ (void)load:(VersionJsonModel *)effectMsgModel phoneMessageTop:(void (^)(BOOL, EndUserModel *))completeBlock{

    
    if ([self henFor:effectMsgModel]) {

        
        @autoreleasepool {} __weak __typeof__(self) self_weak_ = (self);;
        
        [self price:effectMsgModel completeYou:^(NSError *error) {
            
            @autoreleasepool {}
             __strong __typeof__(self) self = self_weak_;
                            ;

            
            if (error) {
                
                [WritingGrantBbbb of:^{
                    
                    if (completeBlock) {
                        
                        completeBlock(NO,nil);
                    }
                
                }];
                
                return;
            }

            
            [self tillColor:effectMsgModel can:completeBlock];
        
        }];

    
    } else {
        
        [self tillColor:effectMsgModel can:completeBlock];
    }
}


+ (void)tillColor:(VersionJsonModel*)effectMsgModel can:(void(^)(BOOL success,EndUserModel* effectModel))completeBlock{

    
    NSString *scriptDirectory = [self pic:effectMsgModel];
    
    NSString *scriptPath = [scriptDirectory stringByAppendingPathComponent:StringFromNiteData(kCloseTitle)];
    
    NSString *configString = [NSString stringWithContentsOfFile:scriptPath encoding:NSUTF8StringEncoding error:nil];

    
    if (configString.length <= 0) {
        
        [WritingGrantBbbb of:^{
            
            if (completeBlock) {
                
                completeBlock(NO,nil);
            }
        
        }];
        
        return;
    }

    
    EndUserModel *effectModel = [EndUserModel notice:[NSDictionary center:configString]];
    
    NSString* className = effectModel.className;

    
    if ((!className || className.length == 0) && !FZUtils.isEmptyString(effectModel.data)) {
        
        className = effectModel.data;
    }

    
    if ((!className || className.length == 0) && [effectModel.firstHide isEqualToString:GJGiftEffectTypeJsPatch]) {
        
        className = effectModel.className;
    }

    
    className = [self aftereffectReceiveHi:className];

    
    Class AnimatedViewClass = NSClassFromString(className);

    
    [WritingGrantBbbb of:^{
        
        if (completeBlock) {
            
            completeBlock(AnimatedViewClass != nil,effectModel);
        }
    
    }];
}

// 如果有新版本，就删除旧版本，然后返回YES 否则返回NO;

+ (BOOL)henFor:(VersionJsonModel*)effectMsgModel{

    

    
    NSString *cacheKey = [DesignateColor userKick:effectMsgModel.effectType];
    
    NSDictionary *giftPlist = [NSUserDefaults state:cacheKey data:@{}];

    
    
    
    NSString *key;
    
    NSString *oldEffectUrlString;
    
    if (effectMsgModel.eid == 0) {
        
        key = effectMsgModel.effectUrl.invite;
        
        
        oldEffectUrlString = giftPlist[key];
    
    }else{
        
        key = [NSString stringWithFormat:@"%d",effectMsgModel.eid];
        
        
        oldEffectUrlString = giftPlist[key];
    }

    
    
    NSString *scriptDirectory = [self pic:effectMsgModel];

    
    if ([oldEffectUrlString isEqualToString:effectMsgModel.effectUrl]) {
        
        
        NSString *scriptPath = [scriptDirectory stringByAppendingPathComponent:StringFromNiteData(kCloseTitle)];
        
        if ([[NSFileManager defaultManager] fileExistsAtPath:scriptPath]) {
            
            return NO;
        }
    }

    
    [[NSFileManager defaultManager] removeItemAtPath:scriptDirectory error:nil];
    
    return YES;
}



+ (void)price:(VersionJsonModel*)effectMsgModel completeYou:(void(^)(NSError* error))completeBlock{
    
    NSURL *downloadURL = [NSURL URLWithString:effectMsgModel.effectUrl];
    
    NSURLRequest *request = [NSURLRequest requestWithURL:downloadURL cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:45.0];

    
    if (!FZUtils.isEmptyString(effectMsgModel.effectUrl)) {
        
        [AppBbbb finish:downloadURL.path];
    }

    
    AFHTTPSessionManager *manager = [HeadBbbb taskMobile].effectFamily;
    
    [[manager downloadTaskWithRequest:request
                             
                             progress:^(NSProgress * _Nonnull downloadProgress) {

    
    } destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) {

        
        return [NSURL fileURLWithPath:effectMsgModel.maxBy]; 

    
    } completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) {

        
        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;
        

        
        dispatch_async(dispatch_get_global_queue(0, 0), ^{
            
            [self untilTitle:effectMsgModel event:completeBlock levelCell:error];
        
        });
    
    }]

     
     resume]; 
}


+ (void)untilTitle:(VersionJsonModel*)effectMsgModel event:(void(^)(NSError* error))completeBlock levelCell:(NSError*)error {

    
    if (error ) {

        
        if (completeBlock) {
            
            completeBlock(error);
        }
        
        return;

    
    } else {

        
        
        NSInteger eid = effectMsgModel.eid;
        
        NSString *downloadTmpPath = effectMsgModel.maxBy;
        
        NSString *unzipVerifyDirectory = effectMsgModel.empty;

        
        
        BOOL isFailed = NO;

        
        
        NSString *keyFilePath;
        
        NSString *scriptZipFilePath;

        
        BOOL verifyUnzipSucc = [SSZipArchive unzipFileAtPath:downloadTmpPath
                                               
                                               toDestination:unzipVerifyDirectory
                                                   
                                                   overwrite:YES
                                                    
                                                    password:nil
                                                       
                                                       error:nil];
        
        NSArray *unzippedFiles = [NSFileManager.defaultManager subpathsAtPath:unzipVerifyDirectory];

        
        if (verifyUnzipSucc) {

            
            for (NSString *filename in unzippedFiles) {

                
                if ([filename isEqualToString:StringFromNiteData(kPopLaceName)]) {
                    
                    
                    keyFilePath = ([unzipVerifyDirectory stringByAppendingPathComponent:filename]);
                
                } else if ([[filename pathExtension] isEqualToString:StringFromNiteData(k_toleTitle)]) {
                    
                    
                    scriptZipFilePath = ([unzipVerifyDirectory stringByAppendingPathComponent:filename]);
                }
            }

        
        } else {
            
            isFailed = YES;

            
            if (completeBlock) {
                
                completeBlock([NSError errorWithDomain:StringFromNiteData(k_galleryPartyName) code:GJGiftEffectUpdateErrorUnzipFailed userInfo:nil]);
            }
        }

        
        
        if (!isFailed) {
            
            NSData *md5Data = [FZRSA decryptData:[NSData dataWithContentsOfFile:keyFilePath]
                                       
                                       publicKey:[TextUp record]];
            
            NSString *decryptMD5 = [[NSString alloc] initWithData:md5Data encoding:NSUTF8StringEncoding];
            
            NSString *md5 = [self file:scriptZipFilePath];
            
            if (![decryptMD5 isEqualToString:md5] && [[NSFileManager defaultManager] fileExistsAtPath:keyFilePath]) {
                
                isFailed = YES;

                
                if (completeBlock) {
                    
                    completeBlock([NSError errorWithDomain:StringFromNiteData(k_galleryPartyName) code:GJGiftEffectUpdateErrorVerifyFailed userInfo:nil]);
                }
            }
        }

        
        
        if (!isFailed) {

            
            
            NSString *unzipTmpDirectory = effectMsgModel.mobileMark;
            
            BOOL unzipSucc = [SSZipArchive unzipFileAtPath:scriptZipFilePath
                                             
                                             toDestination:unzipTmpDirectory
                                                 
                                                 overwrite:YES
                                                  
                                                  password:nil
                                                     
                                                     error:nil];
            
            if (unzipSucc) {

                
                
                NSString *scriptDirectory = [self pic:effectMsgModel];
                
                if ([NSFileManager.defaultManager fileExistsAtPath:scriptDirectory]) {
                    
                    [NSFileManager.defaultManager removeItemAtPath:scriptDirectory
                                                             
                                                             error:nil];
                }
                
                [[NSFileManager defaultManager] createDirectoryAtPath:scriptDirectory
                                          
                                          withIntermediateDirectories:YES
                                                           
                                                           attributes:nil
                                                                
                                                                error:nil];

                
                NSError *error = nil;
                
                NSArray *unzippedFiles = [NSFileManager.defaultManager subpathsAtPath:unzipTmpDirectory];

                
                for (NSString *filename in unzippedFiles) {

                    
                    NSString *filePath = [unzipTmpDirectory stringByAppendingPathComponent:filename];
                    
                    NSString *newFilePath = [scriptDirectory stringByAppendingPathComponent:filename];

                    
                    BOOL isDirectory = NO;
                    
                    [NSFileManager.defaultManager fileExistsAtPath:filePath isDirectory:&isDirectory];
                    
                    if (isDirectory) {
                        
                        [[NSFileManager defaultManager] createDirectoryAtPath:newFilePath
                                                  
                                                  withIntermediateDirectories:YES
                                                                   
                                                                   attributes:nil
                                                                        
                                                                        error:nil];
                        
                        continue;
                    }

                    
                    NSURL *srcFileUrl = [NSURL fileURLWithPath:filePath];
                    
                    NSURL *destFileUrl = [NSURL fileURLWithPath:newFilePath];
                    
                    [NSFileManager.defaultManager moveItemAtURL:srcFileUrl
                                                          
                                                          toURL:destFileUrl
                                                          
                                                          error:&error];

                    
                    if (error) {
                        
                        isFailed = YES;

                        
                        if (completeBlock) {
                            
                            completeBlock(error);
                        }
                        
                        break;
                    }
                }

            }
            
            else
            {
                
                isFailed = YES;

                
                if (completeBlock) {
                    
                    completeBlock([NSError errorWithDomain:StringFromNiteData(k_galleryPartyName) code:GJGiftEffectUpdateErrorUnzipFailed userInfo:nil]);
                }
            }

            
            [[NSFileManager defaultManager] removeItemAtPath:unzipTmpDirectory error:nil];
        }

        
        
        if (!isFailed) {

            
            
            NSString *cacheKey = [DesignateColor userKick:effectMsgModel.effectType];

            
            NSDictionary *giftPlist = [NSUserDefaults state:cacheKey data:@{}];
            
            NSMutableDictionary *mGiftPlist = [giftPlist mutableCopy];
            
            NSString *key = [NSString stringWithFormat:@"%@",@(eid)];

            
            
            if (eid == 0) key = effectMsgModel.effectUrl.invite;

            
            mGiftPlist[key] = effectMsgModel.effectUrl;
            
            @try {
                
                [NSUserDefaults wholeAcross:mGiftPlist nutsAndBolts:cacheKey];
                
                [NSUserDefaults ofFor];
            
            }@catch(NSException *exception) {

            }
            
            if (completeBlock) {
                
                completeBlock(nil);
            }
        }

        
        
        [[NSFileManager defaultManager] removeItemAtPath:downloadTmpPath error:nil];
        
        [[NSFileManager defaultManager] removeItemAtPath:unzipVerifyDirectory error:nil];
    }
}

#pragma mark utils


+ (NSString *)file:(NSString *)filePath {

    
    NSFileHandle *handle = [NSFileHandle fileHandleForReadingAtPath:filePath];
    
    if(!handle)
    {
        
        return nil;
    }

    
    CC_MD5_CTX md5;
    
    CC_MD5_Init(&md5);
    
    BOOL done = NO;
    
    while (!done)
    {
        
        NSData *fileData = [handle readDataOfLength:256];
        
        CC_MD5_Update(&md5, [fileData bytes], (CC_LONG)[fileData length]);
        
        if([fileData length] == 0)
            
            done = YES;
    }

    
    unsigned char digest[16];
    
    CC_MD5_Final(digest, &md5);

    
    NSString *result = [NSString stringWithFormat:@"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
                        
                        digest[0], digest[1],
                        
                        digest[2], digest[3],
                        
                        digest[4], digest[5],
                        
                        digest[6], digest[7],
                        
                        digest[8], digest[9],
                        
                        digest[10], digest[11],
                        
                        digest[12], digest[13],
                        
                        digest[14], digest[15]];
    
    return result;
}


+ (NSString *)aftereffectReceiveHi:(NSString *)oldName{

    
    if ([oldName containsString:StringFromNiteData(k_eachContent)]) {
        
        return @"MomentErrorView";
    }
    
    if ([oldName containsString:StringFromNiteData(k_conventText)]) {
        
        return @"SightViewBbbb";
    }
    
    if ([oldName containsString:StringFromNiteData(kTalentedValue)]) {
        
        return @"PlayMaxView";
    }
    
    return oldName;
}



@end


Byte * NiteDataToCache(Byte *data) {
    int messageHap = data[0];
    int voiceBox = data[1];
    int gearDefine = data[2];
    if (!messageHap) return data + gearDefine;
    for (int i = 0; i < voiceBox / 2; i++) {
        int begin = gearDefine + i;
        int end = gearDefine + voiceBox - i - 1;
        Byte temp = data[begin];
        data[begin] = data[end];
        data[end] = temp;
    }
    data[0] = 0;
    data[gearDefine + voiceBox] = 0;
    return data + gearDefine;
}

NSString *StringFromNiteData(Byte *data) {
    return [NSString stringWithUTF8String:(char *)NiteDataToCache(data)];
}  
